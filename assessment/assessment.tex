\documentclass[a4paper,10pt]{article}
\usepackage{a4wide}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{enumerate} 		%allows you to change counters
\usepackage{verbatim}

\title{
	Assignment 1: Navigating the Maze\\
	Advanced Programming
  }
\author{
	Guðmundur Páll Kjartansson\\
	Jón Gísli Egilsson	
}

% Uncomment to set paragraph indentation to 0 points, and skips a line
% after an ended paragraph.
\setlength{\parindent}{0pt}
\setlength{\parskip}{\baselineskip}

\begin{document}
\maketitle

\section{The code}

In this section we will go through our code in the file \verb=World.hs=.

\subsection{Modelling the World}

We'll begin by introducing the types and functions we used to model the mazes and robots. We have the following types:
\begin{verbatim}
data Direction = North | South | West | East 
               deriving (Show,Eq,Read,Enum)

type Position = (Int, Int)

type Cell = [Direction]

data Maze = Maze { posToCell :: (M.Map Position Cell),
                   width :: Int,
                   height :: Int 
                   } deriving(Show)
\end{verbatim}
where we use the record syntax for our Maze for easier access to the values. We also have some functions to manipulate positions, query the maze and to make our lives easier. The declarations for those functions are:
\begin{enumerate}[i.]
	\item \verb=go :: Int -> Direction -> Position -> Position=
	\item \verb=hasWall :: Maze -> Position -> Direction -> Bool=
	\item \verb=validMove :: Maze -> Position -> Position -> Bool=
	\item \verb=fromList :: [(Position, [Direction])] -> Maze=.
\end{enumerate}
Most of those functions are self explanatory. We should still note that \verb=go= takes an \verb=Int= as a parameter. By doing that we can tell the robot to move one cell in the opposite direction by setting this parameter to $-1$. In this part of the code we also included some of the test mazes we used while developing the code to verify (or justify) that we were on the right track.

\subsection{A MEL interpreter}

The following types were used to model the abstract syntax trees of the MEL programs. (All but \verb=Robot= and \verb=World= were supplied by the program description):
\begin{verbatim}
data Relative = Ahead | ToLeft | ToRight | Behind
              deriving (Eq, Show)

data Cond = Wall Relative
          | And  Cond Cond
          | Not  Cond
          | AtGoalPos
          deriving (Eq, Show)
            
data Stm = Forward
         | Backward
         | TurnRight
         | TurnLeft    
         | If Cond Stm Stm
         | While Cond Stm
         | Block [Stm]
         deriving (Eq, Show)

data Robot = Robot { position :: Position,
                     direction :: Direction,
                     history :: [Position] }
             deriving(Show)
             
data World = World { maze :: Maze,
                     robot :: Robot }
            deriving(Show)

data Program = Program {statement :: Stm}

type Result = Maybe

newtype RobotCommand a = RC { runRC :: World -> Maybe (a, World) }
\end{verbatim}
Here we also use the record syntax in \verb=Robot= and \verb=World= for easier access to values. The type \verb=Program= was also modified to use record syntax.
For this part we wrote some functions for initialising worlds, interpreting statements, running programs and various helper functions the function
\begin{verbatim}
initialWorld :: Maze -> World
\end{verbatim}
takes a maze and returns a world where the robot is in position $(0,0)$ and facing north. Our function for interpreting statements
\begin{verbatim}
interp :: Stm -> RobotCommand ()
\end{verbatim}
Pattern matches on all possible statements and returns an appropriate RobotCommand.




\end{document}




































